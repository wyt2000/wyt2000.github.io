---
layout: post
title:  "计算机组成原理"
date:   2020-09-27 18:48:50 +0800
categories: jekyll update
permalink: /test/
excerpt_separator: <!--more-->
---

# ch1

**冯诺依曼结构数据和指令不分开存储，哈佛结构分开。**

**存储字长：存储单元的位数。**

<!--more--> 

**机器字长：CPU 一次能处理的二进制数据的位数（32 位机器）= CPU 内部通路宽度。**

**指令字长：一个指令的二进制位数，不一定等于机器字长（多字长指令）。**

**数据字长：CPU 外部数据通路宽度 = 系统总线宽度。**

三者可以不等，但必须是字节的整数倍。

存储器带宽：单位时间内从存储器读出的二进制数信息量。

MAR 的位数对应存储单元的个数，MDR 的位数对应存储字长。

存储容量：$2^{MAR}*MDR.$

总线从连接角度分为内部总线、系统总线和 IO 总线；从功能角度分为数据总线、地址总线和控制总线。

CPI ：执行一条指令用的平均周期数

MIPS：一秒钟执行多少百万条指令

MFLOPS：一秒钟执行多少百万条浮点指令。

IC：总指令数

T_clk：一个时钟周期用几秒

阿姆达尔定律：$f_e$ 是可改进的部分占原来总时间的比例，$S_e$ 是可改进部分比改完之后的部分。

系统加速比 $S=\frac1{(1-f_e)+\frac{f_e}{S_e}}.$

CPU 时间 = 指令数 * CPI / 时钟频率。

性能是 CPU 时间的倒数。

# ch2

微指令：微程序级的命令，属于硬件。

宏指令：若干条机器指令组成的命令，属于软件。

机器指令：可完成一个独立的算数逻辑操作。

完善的指令系统有四方面要求：完备性、有效性、规整性、兼容性。

二地址指令可以将运算结果存到 ACC 里，需要 4 次或 3 次访存。

一地址指令的操作数和运算结果都在 ACC 里，只用 2 次访存。

算数移位是有符号移位，逻辑移位是无符号移位。

数据寻址过程就是把操作数的形式地址通过寻址特征变换为操作数的有效地址的过程。

隐含寻址：操作数在 ACC 里。

立即寻址：操作数是立即数。

直接寻址：操作数是 [立即数] 。

间接寻址：操作数是 [[立即数]] 。

寄存器寻址：操作数是寄存器值。

寄存器间接寻址：操作数是 [寄存器值] 。

偏移寻址：操作数是 [基址+偏移量]。隐式偏移：不用在指令中指出寄存器号。

- 相对寻址：PC 是基址，立即数是偏移量。
- **基址寻址：寄存器（BR）值是基址，立即数是偏移量。**
- **变址寻址：立即数是基址，寄存器（IX）值是偏移量。**

**基址寻址用于扩大操作数的寻址范围，如段寻址，变址寻址用于需要频繁修改操作数地址的处理，如数组、字符串、循环。**

**基址寄存器由操作系统赋值，不变；变址寄存器由程序员赋值，可改变。**

堆栈寻址：操作数是 [栈顶] 。

RISC 所有指令长度相同，在一个机器周期内完成，只有 load / store 能访存。

**R 类指令（3个寄存器）：add，寄存器寻址。**

**I 类指令（两个寄存器，一个立即数）：lw sw （基址寻址）addi（寄存器寻址，立即寻址） beq （寄存器寻址，相对寻址）。**

**J 类指令（一个立即数）：J ，26 位地址左移两位与 PC 的高四位拼接（伪直接寻址）。**

# ch3

**时钟周期：计算机时钟间隔的时间。**

**机器周期：也叫 CPU 周期，完成一个基本操作（取指，译码等）所需要的时间称为机器周期。**

**指令周期：CPU 每取出并执行一条指令所需的全部时间。**

**总线周期：CPU 完成一次总线操作（访存或 I/O）的时间。**

DMA 周期：DMA 传输一次从开始到结束的时间？

**一个指令周期 = 多个机器周期 ，一个机器周期 = 多个时钟周期。**

**单周期这三者相等，多周期 1 指令周期 = n 机器周期 = n 时钟周期。**（不同类型指令 n 不一样）

多周期的数据通路是冯诺依曼结构，单周期和流水线是哈佛结构。

只有流水线有段间寄存器。

多周期：R 类指令需要 4 个机器周期，lw 5 个，sw 4 个 ，beq  3 个， j 3 个。

流水线：R 类指令在 MEM 段没用，sw 和 beq 在 WB 段没用。

![image-20200911115711560](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200911115711560.png)

# ch4

吞吐率：单位时间内完成的工作量。

最大吞吐率：流水线中最慢一段所用时间的倒数。

实际吞吐率：$m$ 段流水线完成 $n$ 个任务，则

总时间 $T = (\sum \limits_{i=1}^m \Delta t_i)+(n-1) \max t_i.$

实际吞吐率 $TP=\frac n T.$ 

最大加速比：$m$ 。

**实际加速比：不用流水线的总时间与流水线总时间的比。**

$S = \frac{n\sum \limits_{i=1}^m \Delta t_i}{T}$

某个流水段的效率：某个流水段有效工作的总时间与流水线总时间的比。

$E_i = \frac{n\Delta t_i}{T}.$

**总效率：流水段有效工作的总时间与流水线总时间的比。**

$E = \frac{n\sum \limits_{i=1}^m \Delta t_i}{mT}=\frac{S}{m}.$

等待时间：整个任务所需的时间。

流水线不能缩短单个任务的响应时间，但是可以提高吞吐率。

相关：结构相关、数据相关、控制相关。

数据相关：

- RAW ：读了还没写完的寄存器。
- WAW：后面的指令先写回，前面的指令再写回。
- WAR：后面的指令先写回，前面的指令再读。

延迟分支：从前调度、从目标处调度、从失败处调度。

静态分支预测：投机执行。

动态分支预测：分支预测器——两位转移预测缓冲器。

# ch5

中断的作用/原因：

- 异常：响应软硬件错误或故障。
- I/O ：响应外设的中断。
- 并发：提高计算机的整机效率。
- 服务：用户程序与 OS 间交互（陷阱）。

发生和处理的时机：

- I/O 中断：随时发生，延迟到 WB 段统一处理。
- 异常：随时发生，在哪一段发生就在哪一段处理。
- 陷阱：专用指令，特殊处理（也是同步处理）。

**中断系统组成：**

- **CPU 中断使能：程序状态寄存器 PSW 的 IF 位。**
- **CPU 中断请求/响应标记位：INTR、INTA 。**
- **中断响应返回：中断隐指令。**
- **断点/现场保存：内存或栈。**
- **中断服务**
  - **中断源识别\判断优先级：中断控制器**
  - **ISR 入口：向量方式、非向量方式。**

各中断源同时提出请求，可以通过程序查询或排队器的方法判优。

保护现场：保存断点由中断隐指令完成，保存寄存器内容由中断服务程序完成；恢复现场全部由中断服务程序完成。

**中断响应的过程：**

- **保存断点。**
- **关中断。**
- **找中断服务程序入口地址。**
- **保护现场。**
- **开中断。**
- **执行中断服务程序。**
- **关中断**
- **恢复现场。**
- **开中断。**
- **中断返回。**

实现多重中断的条件：提前开中断，优先级高的中断源可以中断优先级低的中断。

保护现场之后开中断，服务程序执行结束后关中断，恢复现场后再开中断。ISR 可以被打断，但保存和恢复现场不能，设置屏蔽字也要在关中断的范围内。

**响应优先级不可改变，处理优先级可以改变。唐书 P368**

异常处理的过程：

- 断点保存。
- 异常识别。
- 跳转到异常服务程序。

非精确异常：异常不与导致异常的指令精确关联（EPC 是 IF 段的 PC 而不一定是出错段的 PC）。

缺点：异常响应时间较长，程序可能出错，调试不便。

精确异常：提交点。

# ch6

存储器的**存储周期**是连续两次读写操作所需的最小间隔时间，一般大于存取时间。

提高存储器带宽的措施：

- 缩短存取时间和存储周期。
- 增加存储字长。
- 增加存储体。

**地址线 n 根，数据线 m 根，则芯片容量为 $2^n*m\ bits$ 。**

DRAM 刷新方式：集中刷新、分散刷新、异步刷新。

刷新一次按行刷新，刷新间隔为 2ms 。

死区：刷新所用总时间 = 存取周期 * 行数。

死时间率 = 刷新所用总时间 / 刷新时间间隔。

分散刷新没有死区，存取周期变长。

并行存储：单体单字，单体多字，多体并行。

单体多字：一个周期内，从同一地址开始顺序读出4条指令字，逐条送去 CPU 执行。

**多体并行：多个独立存储体。**

- **高位交叉编址：顺序存储，高地址是体号，低地址是体内地址。方便扩容。**
- **低位交叉编址：交叉存储，下一个数据在另一个存储体上，低地址是体号，高地址是体内地址。提高带宽。**

**$T$ 为存储周期，$t$ 为总线传输周期。**

**则顺序读取连续 $m$ 个字所需总时间：$mT.$ （发一次读请求的过程中总线空闲，等数据返回再发第二次读请求）**

**交叉读取连续 $m$ 个字所需总时间：$T+(m-1)t.$ （一次性发 $m$ 个读请求，当第一次数据返回后每隔 $t$ 时间返回下一个数据）。**

码距：两个码字中间不同的二进制位数。

查错 D 位，纠错 C 位，最小码距 L ，则有：

$D \ge C$ 且 $D+C \le L-1.$

**奇偶校验：**

- **加上一位，使 1 的总数为奇数或偶数。**
- **能查一位错，不能纠错。**
- **偶校验所有位加起来是 0 ，奇校验所有位加起来是 1 就没错，否则就有错。**

**海明码：**

- **有 k 个数据，则需要满足 $2^r-1 \ge r+k$ 的 r 个校验位，第 $i$ 个校验位放在编号 $2^{i-1}$ 的位置。**
- **能查 1 位错，纠 1 位错。**

**CRC 码：（n+k,n）码表示将 n 位数据后面加上 k 个 0，除以 k + 1 位的生成多项式。**

单纠错海明码的码距为 3 。

Cache 与主存之间的数据交换以块为单位。

cache 的访问效率 = 命中时的访问时间 / 平均访问时间。

平均访问时间 = 命中率 * cache 时间 + (1 - 命中率) * 访存时间。

cache 容量增大，命中率增大；总容量一定，cache 块增大，命中率先增大后降低。

**cache 地址映射的方式：设主存大小 $2^x$ ，主存的块大小（字） = cache 的块大小为 $2^w$  ，则主存共 $2^{x-w}$ 个块。**

- **全相联映射：主存的每个字块可以映射到 cache 的任何一个块上。主存地址的低 $w$ 位为块内偏移（字），高 $x-w$ 位为块号，对应 cache 的 tag ，cache 通过同时比较所有行的 tag 是否有和主存的块号一样的来确定命中。**
- **直接映射：设 cache 有 $2^r$ 行（块），主存地址的低 $w$ 位为块内偏移（字），高 $x-w$ 位中，低 $r$ 位对应 cache 的行号，高 $x-w-r$ 位对应 cache 的 tag 。比较地址低 $r$ 位对应 cache 行的 tag 是不是等于地址高 $x-w-r$ 位确定命中。**
- **组相联映射：$v$ 路组相联是指每组有 $v$ 个块。设 cache 有 $2^k  = \frac{2^r}{v}$ 组，主存地址的低 $w$ 位为块内偏移（字），高 $x-w$ 位中，低 $k$ 位对应 cache 的组号，高 $x-w-k$ 位对应 cache 的 tag 。同时比较地址低 $k$ 位对应 cache 组的所有 tag 是否有和主存的高 $x-w-k$ 位一样的来确定命中。**

cache 的写策略：

- 写回 - 按写分配（写时取）：命中时只写 cache ，失效时先从主存调块进 cache，再只写 cache 。
- 写回 - 不按写分配（绕写法）：命中时只写 cache，失效时只写主存。
- 写直达 - 按写分配：命中时写 cache 写主存，失效时调块，写 cache 写主存。
- 写直达 - 不按写分配：命中时写 cache 写主存，失效时只写主存。

程序的重定位：虚实地址转换的过程。

在多用户多任务系统中，虚地址空间可以远小于实地址空间，从而缩短指令中地址字段的长度。

cache 和主存构成系统内存，主存和辅存构成虚存。

虚存和 cache 的相同点：都利用了局部性原理，使性能接近高速存储器，价格和容量接近低速存储器。

不同点：

- cache 解决速度，虚存解决容量问题。
- cache 未命中时 CPU 可以直接访存，主存未命中时只能调页。
- cache 只由硬件管理，对系统和应用程序员都透明；虚存由软件（操作系统）和硬件共同管理，对系统程序员不透明。
- 主存未命中时的代价远大于 cache。

虚存分为页式、段式和段页式存储。

页表基址保存在页表基址寄存器里，页表本身保存在主存里。

二级页表：页目录表在主存中，二级页表一部分在主存中，一部分在辅存中。

反向页表：物理页（少）到逻辑页（多）的映射。优点占空间少，缺点查找时间长。

**TLB（快表）：对页表进行二级缓存，将最活跃的部分放到 cache 中。主存中的页表叫慢表。**

**慢表按地址访问（将逻辑页号作为表项的索引），快表按内容比较（将逻辑页号作为关键字在表项中查找）。**

**分页的优点：页长固定，便于管理，没有碎片。**

**缺点：页长与程序逻辑大小无关，不利于编程的独立性以及复杂的存储管理操作，占用空间比段表大。**

**分段的优点：有逻辑独立性，便于操作，段长可变，能有效利用主存空间。**

**缺点：空间分配复杂，有碎片，空间利用率低，需要更多硬件支持。**

段按程序的自然边界划分，大小可变，分段对程序员可见。

段表表项：有效位、段起始地址、段长。有效位为0，产生缺页中断；段内地址大于段长，产生越界中断。

段页式虚存：程序先按逻辑结构分段，每个段再按主存的页大小分页，一个程序有一个段表和多个页表。

FIFO + LRU：没命中时替换队首的页，命中时将命中的页移到队尾。

# ch7

总线频率：每秒传输几次。

总线宽度：每次传输几个字节。

总线带宽 ：每秒传输的总字节数。

总线仲裁：集中式仲裁、分布式仲裁。

集中式仲裁：

- 链式查询：
  - 优点：硬件连线简单，且易于扩充。
  - 缺点：对电路故障敏感，优先级低的设备很难获得请求。
- 计数器定时查询：
  - 优点：设备优先级可变，对电路故障不敏感。
  - 缺点：电路控制复杂。
- 独立请求查询：
  - 优点：响应时间快，对优先次序的控制十分灵活。
  - 缺点：控制线数量多，控制更复杂。

分布式仲裁：自举、冲突检测、并行竞争。

先写后读一般用于校验目的，先读后写多用于多道程序系统中对共享存储资源的保护。

总线周期分为申请分配阶段、寻址阶段、传送阶段、结束阶段。

**总线通信控制方式：**

- 同步通信
  - 优点：模块间配合简单一致。
  - 缺点：强制同步，需要按速度最慢的部件设计时钟，影响效率
- 异步通信
  - 不互锁：不管是否收到应答都访问，出错就报异常。
  - 半互锁：收到应答才访问。
  - 全互锁：收到应答后再发一次请求通知对方要访问了，再开始访问。
- 半同步通信
  - 优点：控制方式简单；各模块由统一时钟控制同步工作，可靠性较高。
  - 缺点：等待时间不确定导致工作效率低。
- 分离式通信

比特率：单位时间内传送的有效数据位数。

波特率：单位时间内传送的全部数据位数。

异步串行传送起始位 0 后传输数据位的最低位，数据位的最高位之后传输校验位，最后终止位 1 。

# ch8

通道：计算机系统中代替CPU管理控制外设的独立部件，是一种能执行有限I/O指令集合——通道命令的I/O处理部件。

I/O处理机：独立于主机，可完成I/O通道要完成的I/O控制，以及数据处理、转换、检错纠错等操作。

DMA：I/O设备与主存之间使用一条直接的数据通路。

I/O接口：也叫适配器，指主机与I/O设备间设置的硬件电路及其相应的软件控制。

端口：接口电路中的寄存器。端口加控制逻辑组成接口。

**I/O 信息交换方式：**

- **程序查询方式**
- **程序中断方式**
- **DMA方式**
- **通道方式**

数据传输前后的准备和处理工作由 CPU 上的管理程序做，DMA 只负责数据传输。

CPU和DMA同时请求访存——DMA优先。

磁盘扇区定位采用随机读写方式，扇区内采用顺序读写方式。

道密度：沿半径方向单位长度磁道数。

位密度：单位长度磁道的数据位数。

**每道的总位数相同，周长不同，取的是最小的周长。**

**磁盘总容量 = 盘面数 * （一面的总磁道数 = 道密度 * 半径）*（一圈磁道的总位数 = 位密度 * 内圈周长）。**

**传输率：单位时间内传输的数据量 = 转速 * （一圈磁道的总位数 = 位密度 * 内圈周长）。**

**平均寻址时间 = 平均寻道时间（定位时间）+ 平均等待时间（转一圈时间的一半）。**

**寻道时间一般比旋转延迟大。**